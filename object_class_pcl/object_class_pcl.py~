#!/usr/bin/env python

import rospy, utils, math, image_geometry, tf, operator
import tf.transformations as tf_help
import numpy as np
from sensor_msgs import point_cloud2 as pc2
from sensor_msgs.msg import Image, PointCloud2, CameraInfo, PointField

NS = 'fire_detector'
NODE_NAME = 'thermo_to_pcl'
PARAM_PREFIX = NS + '/' + NODE_NAME + '/'

PARAM_LIST = [	('in_pcl', 'dynamic_point_cloud'),
		('out_pcl', 'dynamic_point_cloud_thermo'),
		('in_thermo', 'thermo'),
		('max_thermo_age', 8),
		('max_pcl_age', 5),
		('transform_wait', 0.2),
		('base_frame', 'odom'),
		('thermo_frame', 'xthermo_base_link'),
		('default_thermo', -200),
		('image_rate', 5)]

class ToPCL:
	def __init__(self):
		rospy.init_node(NODE_NAME)
		for name, default in PARAM_LIST:
			setattr(self, name, rospy.get_param(PARAM_PREFIX + name, default))

		rospy.Subscriber(self.in_pcl, PointCloud2, self.pcl_cb)
		rospy.Subscriber(self.in_thermo + '/camera_info', CameraInfo, self.ci_cb)
		rospy.Subscriber(self.in_thermo + '/image_raw', Image, self.image_cb)
		self.pcl_pub = rospy.Publisher(self.out_pcl, PointCloud2, queue_size=20)
		self.thermos = {}
		self.cis = {}
		self.counter = 0
		self.tf_listener = tf.TransformListener()
		self.adjustment = np.dot(tf_help.rotation_matrix(math.pi/2, (0,1,0)), tf_help.rotation_matrix(math.pi, (0,0,1)))

	def pcl_cb(self, pcl):
		if len(pcl.data) is 0:
			rospy.logwarn('No points')
			return
		if len(self.thermos) == 0:
			rospy.logwarn('There are not any thermo images!')
			return
		if (rospy.Time.now() - pcl.header.stamp).to_sec() > self.max_pcl_age:
			rospy.logwarn('Too old pointcloud! Skipping!')
			return
		cloud = list(pc2.read_points(pcl, skip_nans=True))
		np_cloud = utils.cloud_to_numpy(cloud)
		transforms = {}
		use_thermo = self.thermos.copy()
		keys = sorted(use_thermo.keys(), reverse=True)
		use_ci = self.cis.copy()
		thermo_data = np.zeros((np_cloud.shape[0],)) + self.default_thermo
		for key in keys:
			if key not in use_ci:
				rospy.logwarn("Don't have camerainfo yet for image with stamp " + str(key))
				continue
			try:
				self.tf_listener.waitForTransformFull(self.thermo_frame, key, pcl.header.frame_id, pcl.header.stamp, self.base_frame, rospy.Duration(self.transform_wait))
				transforms[key] = self.tf_listener.fromTranslationRotation(*self.tf_listener.lookupTransformFull(self.thermo_frame, key, pcl.header.frame_id, pcl.header.stamp, self.base_frame))
			except tf.Exception as exc:
				rospy.logwarn(exc)
				break

		for key in transforms:
			cam_cloud = np.dot(transforms[key], np_cloud.T).T
			cam_cloud = cam_cloud.dot(self.adjustment.T)
			cam_valid = np.where(cam_cloud[:,2] >= 0)[0]
			cam_data = cam_cloud[cam_valid]
			cam_data = cam_data.reshape((np.product(cam_data.shape)/4, 4))
			width = use_thermo[key].width
			height = use_thermo[key].height
			cam_mat = np.array(use_ci[key].P).reshape((3,4))
			cam_data = cam_mat.dot(cam_data.T).T
			div = cam_data[:,2]
			x = np.round(cam_data[:,0]/div)
			y = np.round(cam_data[:,1]/div)

			pix_x = np.where((0 <= x) & (x < width))[0]
			pix_y = np.where((0 <= y) & (y < height))[0]
			
			pix_valid = np.intersect1d(pix_x, pix_y)
			pix_coords = np.c_[x[pix_valid], y[pix_valid]]
			valid = cam_valid[pix_valid]

			coords = np.rint(pix_coords).astype(int)
			ind = coords.dot(np.array([1, width]).reshape((2,1)))
			th_data = np.array(use_thermo[key].data)
			thermo_data[valid.T] = th_data[ind]
		
		all_valid = np.where(thermo_data != self.default_thermo)[0]
		rospy.loginfo('Found temperature for %d points out of %d' % (all_valid.size, thermo_data.size))
		if all_valid.size is not 0:
			thermo_field = PointField(name='thermo', offset=(pcl.fields[-1].offset + 4), datatype=PointField.FLOAT32, count=1)
			rgb, x, y, z, i = zip(*cloud)
			get_fun = operator.itemgetter(*(all_valid.tolist()))
			i = get_fun(i)
			x = get_fun(x)
			y = get_fun(y)
			z = get_fun(z)
			thermo = thermo_data[all_valid]
			rgb = thermo_to_rgb(thermo)
			data = zip(rgb, x, y, z, i, thermo)
			msg = pc2.create_cloud(pcl.header, pcl.fields + [thermo_field], data)
			self.pcl_pub.publish(msg)

	def ci_cb(self, ci):
		self.cis[ci.header.stamp] = ci
		self.rm_old(self.cis)

	def rm_old(self, data):
		now = rospy.Time.now()
		rm = [key for key in data if (now - key).to_sec() > self.max_thermo_age]
		for key in rm:
			del data[key]

	def image_cb(self, image):
		if self.counter is 0:
			thermo = utils.image_to_thermo(image)
			self.thermos[thermo.header.stamp] = thermo
			self.rm_old(self.thermos)
		self.counter += 1
		self.counter %= self.image_rate
		
def thermo_to_rgb(thermo):
	min_thermo = np.min(thermo)
	max_thermo = np.max(thermo)
	rospy.loginfo('Min and max temperature: %.2f, %.2f' % (min_thermo, max_thermo))

	scaled = ((thermo - min_thermo)/(max_thermo - min_thermo))
	z = np.zeros(thermo.shape)
	o = np.zeros(thermo.shape)
	r = np.minimum(np.maximum(z, 1.5 - abs(1 - 4*(scaled-0.5))),o)
	g = np.minimum(np.maximum(z, 1.5 - abs(1 - 4*(scaled-0.5))),o)
	b = np.minimum(np.maximum(z, 1.5 - abs(1 - 4*(scaled-0.5))),o)
	
	mat = (256*256*256 - 1) * r + (256*256 - 1) * g + 255 * b
	return mat
	
	
if __name__ == '__main__':
	pcl = ToPCL()
	rospy.spin()
